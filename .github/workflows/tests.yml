name: Build check

on:
  push:
    branches: [ "**" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile-and-wait:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure repository is PUBLIC
        if: ${{ github.event.repository.private }}
        run: |
          echo "❌ Этот форк приватный. Для автопроверки сделайте репозиторий PUBLIC (или дайте преподавателю доступ)."
          exit 1

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Compile sources
        run: |
          FILES=$(find src/main/java -name "*.java")
          if [ -z "$FILES" ]; then
            echo "❌ В каталоге src/main/java не найдены .java файлы."
            exit 1
          fi
          javac $FILES
          echo "✅ Код скомпилирован. Ожидаем результаты приватной проверки…"

      # jq обычно есть на раннере, но подстрахуемся
      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Wait for private grading comment (print full log)
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA:  ${{ github.sha }}
          GRADER_PREFIX: "Grading result:"
          MAX_TRIES: "60"     # ~30 минут ожидания
          SLEEP_SEC: "30"
        shell: bash
        run: |
          echo "Ожидаем комментарий от приватного грейдера для $REPO@$SHA …"
          i=0
          BODY=""

          while [ $i -lt $MAX_TRIES ]; do
            # Берём комментарии к коммиту, сортируем по времени (новые сначала)
            RESP=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
            BODY=$(echo "$RESP" \
              | jq -r 'sort_by(.created_at) | reverse | .[] | .body
                       | select(startswith(env.GRADER_PREFIX))' \
              | head -n1)

            if [ -n "$BODY" ] && [ "$BODY" != "null" ]; then
              break
            fi

            i=$((i+1))
            echo "… пока нет (попытка $i/$MAX_TRIES). Спим $SLEEP_SEC сек."
            sleep "$SLEEP_SEC"
          done

          if [ -z "$BODY" ] || [ "$BODY" = "null" ]; then
            echo "::warning::Не дождались приватной проверки. Загляните позже в комментарии к коммиту или в общий отчёт преподавателя."
            exit 0
          fi

          echo
          echo "━━━━━━━━━━━━ РЕЗУЛЬТАТ ПРИВАТНЫХ ТЕСТОВ ━━━━━━━━━━━━"
          # печатаем весь комментарий целиком (со всеми строками и код-блоком)
          printf "%s\n" "$BODY"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo

          # отдельно вытащим код-блок из комментария и напечатаем как «сырой» лог
          LOG=$(printf "%s\n" "$BODY" | awk 'BEGIN{p=0}
            /^```/ {p=!p; next} p==1 {print}')
          if [ -n "$LOG" ]; then
            echo "▼ Лог из приватной проверки (как есть)"
            printf "%s\n" "$LOG"
            echo "▲ Конец лога"
          fi

          # успешность определяем по первой строке
          FIRST_LINE=$(printf "%s\n" "$BODY" | head -n1)
          if echo "$FIRST_LINE" | grep -qiE '^Grading result:\s*OK\b'; then
            echo "✅ Приватные тесты пройдены."
            exit 0
          else
            echo "❌ Приватные тесты НЕ пройдены."
            exit 1
          fi
